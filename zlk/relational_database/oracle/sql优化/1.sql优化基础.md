## 1 sql优化基础入门

### 1 数据分布于索引选择

基数：某列唯一键的数量叫基数。如列为性别（男或者女），基数为2。

索引选择：查询数据在表的5%以内，走索引。超过5%,走全表扫描。

基数不均匀可能会导致全表扫描，使用下面语句查看数据分布均衡情况（列做条件时，查询结果和5%有关系）
	
	select * from 列,count(*) from 表名 group by 列 order by 2 desc --第二列降序


### 2 索引列选择

**索引对数据量大时效果才明显**

2.1 选择性：基数/总行数*100  （某列），故当基数很低时，越可能不均衡。

	当选择性大于20%，数据比较均衡，该列需要使用索引。

2.2 索引失效

	 1．隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误.
	 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效.
	 错误的例子：select * from test where tu_mdn=13333333333;
	 正确的例子：select * from test where tu_mdn='13333333333';

	 2. 对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等)
	 错误的例子：select * from test where id-1=9;
	 正确的例子：select * from test where id=10;

	 3. 使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引.
	 错误的例子：select * from test where round(id)=10; 说明，此时id的索引已经不起作用了
	 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select * from test where round(id)=10; 这时函数索引起作用了

	 4. 以下使用会使索引失效，应避免使用；
	 a. 使用 <> 、not in 、not exist、!=
	 b. like "%_" 百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理）
	 c. 单独引用复合索引里非第一位置的索引列.应总是使用索引的第一个列，如果索引是建立在多个列上, 只有在它的第一个列被where子句引用时，优化器才会选择使用该索引。
	 d. 字符型字段为数字时在where条件里不添加引号.
	 e. 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。

	 5. 不要将空的变量值直接与比较运算符（符号）比较。
	 如果变量可能为空，应使用 IS NULL 或 IS NOT NULL 进行比较，或者使用 ISNULL 函数。

	 6. 不要在 SQL 代码中使用双引号。
	 因为字符常量使用单引号。如果没有必要限定对象名称，可以使用（非 ANSI SQL 标准）括号将名称括起来。

	 7. 将索引所在表空间和数据所在表空间分别设于不同的磁盘chunk上，有助于提高索引查询的效率。
	 
	 8. Oracle默认使用的基于代价的SQL优化器（CBO）非常依赖于统计信息，一旦统计信息不正常，会导致数据库查询时不使用索引或使用错误的索引。
	 一般来说，Oracle的自动任务里面会包含更新统计信息的语句，但如果表数据发生了比较大的变化（超过20%）,可以考虑立即手动更新统计信息，例如：analyze table abc compute statistics，但注意，更新   统计信息比较耗费系统资源，建议在系统空闲时执行。

	 9. Oracle在进行一次查询时，一般对一个表只会使用一个索引.
	 因此，有时候过多的索引可能导致Oracle使用错误的索引，降低查询效率。例如某表有索引1（Policyno）和索引2（classcode），如果查询条件为policyno = ‘xx’ and classcode = ‘xx’，则系统有可能会使用索   引2，相较于使用索引1，查询效率明显降低。

	 10. 优先且尽可能使用分区索引。


2.3 索引列抓取优化脚本。。。。。。。

2.4 直方图
	
数据分布不均匀时（**选择性小于1%**），需要直方图。

	EXPLAIN PLAN FOR select * from test where owner='SCOTT';
	
    select * from table(dbms_xplan.display());

2.5 回表

通过索引中rowid访问表中的数据叫回表。回表是单块读，回表太多的话会影响sql性能，当回表次数太多不应该走索引扫描。(一定要注意回表次数，特别是回表的物理I/O次数)。索引返回数据多的话，回表次数会多。**（5%）**

SELECT * 必须回表，严禁使用。多条件时可以采取组合索引来消除回表，再过滤。  

2.6 集团因子     

索引回表需要消耗的物理I/O次数。

如果没办法避免回表，可以考虑把数据块缓存到buffer cache中。

2.7 表与表之间的关系

	1:1   一对一
	1:N   一对多
	N:N   多对多



