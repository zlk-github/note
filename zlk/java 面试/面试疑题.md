## 面试题整理

### 1 分数转优秀

	create table grade_table(
	       id integer not null , 
	       chinese  number(4,1) not null , --中文成绩
	       english  number(4,1) not null , -- 英语成绩
	       math  number(4,1) not null  , --数学成绩
	       primary key(id)
	)
	
	insert into grade_table(id,chinese,english,math) values(1002,91,70,59);
	insert into grade_table(id,chinese,english,math) values(1001,90,80,60);
	
	select id,
		case  when chinese>=90 then '优秀' when chinese>=80 then '良好' when chinese>=70 then '中等' when chinese>=60 then '及格'  else '不及格' end as 语文,
		case  when english>=90 then '优秀' when english>=80 then '良好' when english>=70 then '中等' when english>=60 then '及格'  else '不及格' end as 英语,
		case  when math>=90 then '优秀' when math>=80 then '良好' when math>=70 then '中等' when math>=60 then '及格'  else '不及格' end as 数学
	from grade_table

结果：

	ID      语文   英语   数学
	1002	优秀	 中等	  不及格
	1001    优秀   良好	  及格


###  2 行变列

**2.1.oracle行变列**
	
	create table grade_table2(
	       id integer not null , 
	       s_id integer not null , -- 学号
	       c_name varchar2(50)  not null, -- 课程名称
	       score  number(4,1) , --成绩
	       primary key(id)
	)
	
	insert into grade_table2(id,s_id,c_name,score) values(1001,20141001,'语文',90);
	insert into grade_table2(id,s_id,c_name,score)  values(1002,20141001,'英语',85);
	insert into grade_table2(id,s_id,c_name,score)  values(1003,20141001,'数学',70);
	
	insert into grade_table2(id,s_id,c_name,score)  values(1004,20141002,'语文',80);
	insert into grade_table2(id,s_id,c_name,score)  values(1005,20141002,'英语',98);
	insert into grade_table2(id,s_id,c_name,score)  values(1006,20141002,'数学',77);


测试数据如下：

        id      s_id        c_name   score
	1	1001	20141001	语文	    90.0
	2	1002	20141001	英语      85.0
	3	1003	20141001	数学	    70.0
	4	1004	20141002	语文	    80.0
	5	1005	20141002	英语	    98.0
	6	1006	20141002	数学	    77.0

	
测试1：将行换列

	select  s_id 学号,
	             MAX(case  when c_name= '语文' then  score ELSE 0 END) 语文,
	             MAX(case  when c_name= '数学' then  score ELSE 0 END) 数学,
	             MAX(case  when c_name= '英语' then  score ELSE 0 END) 英语  
	 from grade_table2  GROUP BY s_id 

结果1
		
		学号        语文 数学 英语    
	1	20141001	90	70	85
	2	20141002	80	77	98


测试2：行换列，并把分数分等级
	 
	 select       s_id 学号,
	              MAX(case  when c_name='语文'  then (case when   score>=90 then '优秀' when score>=80 then '良好' when score>=70 then '中等' when score>=60 then '及格'  else '不及格' end)  else '' end) 语文,
	              MAX(case  when c_name='数学'  then (case when   score>=90 then '优秀' when score>=80 then '良好' when score>=70 then '中等' when score>=60 then '及格'  else '不及格' end)  else '' end) 数学,
	              MAX(case  when c_name='英语' then  (case when   score>=90 then '优秀' when score>=80 then '良好' when score>=70 then '中等' when score>=60 then '及格'  else '不及格' end)  else '' end)  英语  
	 from grade_table2  GROUP BY s_id 

结果2

		学号        语文  数学  英语
	1	20141001	优秀	中等	良好
	2	20141002	良好	中等	优秀



###  3 多级缓存

###  4 MySQL引擎
	
	MyISAM：默认的MySQL插件式存储引擎（MySQL 5.1前），它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。注意，
	通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。表级锁、不支持事务和全文索引，适合一些CMS
	内容管理系统作为后台数据库使用，但是使用大并发、重负荷生产系统上，表锁结构的特性就显得力不从心；（适合查询）
	
	InnoDB：默认的MySQL插件式存储引擎（MySQL 5.5后）用于事务处理应用程序，具有众多特性，包括ACID事务支持。(提供行级
	锁)，行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。
	InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。InnoDB是为处理巨大量时拥有最大性能而设计的。
	它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。InnoDB表的行锁也不是绝对的。（适合更新）
	
	BDB：可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性。
	
	Memory：将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。
	
	Merge：允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。
	对于诸如数据仓储等VLDB环境十分适合。
	
	Archive：为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。
	
	Federated：能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。
	
	Cluster/NDB：MySQL的簇式数据库引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。
	
	Other：其他存储引擎包括CSV（引用由逗号隔开的用作数据库表的文件），Blackhole（用于临时禁止对数据库的应用程序输入），
	以及Example引擎（可为快速创建定制的插件式存储引擎提供帮助）。

###  5 MySQL编码utf-8与utf-8mb4

	MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，
	除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。原来mysql支持的 utf8 编码最大字符长度
	为 3 字节。为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8.  对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，
	根据 Mysql 官方建议，使用 VARCHAR  替代 CHAR。

	MySQL 5.0以上的版本：
	一个汉字占多少长度与编码有关：
	UTF－8：一个汉字＝3个字节
	GBK：一个汉字＝2个字节

### 6 nginx配置，使用

https://blog.csdn.net/qq_34553637/article/details/91126671

反向代理的作用：

	1.负载均衡，提高请求处理与响应速度（集群）;
	2.保证内网安全，隐藏服务器信息，防止web攻击。

### 7 spring常用设计模式

https://blog.csdn.net/weixin_41648325/article/details/79922976

我们通常说的 23 中经典设计模式可以通过下表一目了然：

	 创建型 
	工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、 建造者模式（Builder）、原型模式（Prototype）、单例模式(Singleton)
	结构型
	适配器模式(Adapter)、桥接模式（Bridge）、组合模式（Composite）、 装饰器模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）、 代理模式（Proxy）
	行为型
	解释器模式（Interpreter）、模板方法模式（TemplateMethod）、 责任链模式（ChainofResponsibility）、命令模式（Command）、
	 迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、 观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、 访问者模式（Visitor）

**第一种：简单工厂模式（不在23中之中）**

其有一个创建Bean对象的工厂类，当需要创建对象时，通过传入一个id标识来动态的生产电影Bean对象。（id的判断逻辑在工厂内）

spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。

	<beans>
	    <bean id="singletonBean" class="com.itxxz.HelloItxxz"  singleton="false">
	        <constructor-arg>
	            <value>Hello! 这是singletonBean!value>
	        </constructor-arg>
	</ bean>

穷举：批量化，标准化。

**第二种：工厂方法模式**

通常由应用程序直接使用 new 创建新的对象，为了将对象的创建和使用相分离，采用工厂模 式,即应用程序将对象的创建及初始化职责交给工厂对象。 一般情况下,应用程序有自己的工厂对象来创建 Bean.如果将应用程序自己的工厂对象交给 Spring 管 理,那么 Spring 管理的就不是普通的 Bean,而是工厂 Bean。（id的判断逻辑在客户端）


穷举：流水线生产。

**第三种：单例模式**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 
核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定

**第四种：适配器模式**

Spring AOP 模块对 BeforeAdvice、AfterAdvice、ThrowsAdvice 三种通知类型的支持实际上是借 助适配器模式来实现的，这样的好处是使得
框架允许用户向框架中加入自己想要支持的任何一种通知类 型，上述三种通知类型是 Spring AOP 模块定义的，它们是 AOP 联盟定义的 Advice 的子类型。拦截器的实现。

**第五种：包装器**

比较常见的是多数据源的切换。

Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator。基本上都是动态地给一个对象添加一些额外的职责。


**第六种：代理**

为其他对象提供一种代理以控制对这个对象的访问。  从结构上来看和Decorator（包装器）模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 
spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 

穷举：中介

**第七种：观察者**

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 

**第八种：策略**

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 
spring中在实例化对象的时候用到Strategy模式
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： 
 
**第九种：模板方法**

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 

以下是一个具体的例子： 
JdbcTemplate中的execute方法 

模式：

![Alt text](./images/ms.png)



### spring注解

### solr

### 高并发

	1.做负载均衡:集群；
	2.资源动静分离（静态资源由nginx提供，动态资源由tomcat提供:使用nginx或者DNS；
	3.缓存:以空间换时间，提高效率；
	4.限流：流量控制（队列实现）；
	5.降级：在并发量特别高时，可以暂时关掉非核心服务。（如日志等只保留报错，警告日志暂时关掉等）。
	6.非关系型数据库。

###  mysql 分区

	RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。
	
	LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。
	
	HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。
	
	KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。

注：支持1024个分区。如果表写入频繁，数据1000w+，可以考虑分区。

### vi2000行

### 字符转字节

### http与https

### 1产生锁，解决锁。2建表表空间注意.3mvc.4单点登录的实现。5事务的类型

### Java编程思想，Java开发指南